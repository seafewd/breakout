    private void doBallBrickCollision(){
        for (Brick b : bricks) {

            // Vertices
            if(intersects(b) && getBallOrientation(b) == Orientation.TOP){
                points += b.getPoints();
                toRemove.add(b);
                ball.setyVelocity(-Math.abs(ball.getyVelocity()));
            }
            else if(intersects(b) && getBallOrientation(b) == Orientation.BOTTOM){
                points += b.getPoints();
                toRemove.add(b);
                ball.setyVelocity(Math.abs(ball.getyVelocity()));
            }
            else if(intersects(b) && getBallOrientation(b) == Orientation.RIGHT){
                points += b.getPoints();
                toRemove.add(b);
                ball.setxVelocity(Math.abs(ball.getxVelocity()));
            }
            else if(intersects(b) && getBallOrientation(b) == Orientation.LEFT){
                points += b.getPoints();
                toRemove.add(b);
                ball.setyVelocity(-Math.abs(ball.getxVelocity()));
            }
            // Corners

            else if(intersects(b) && getBallOrientation(b) == Orientation.TOP_RIGHT){
                if(getDirection(b) == Direction.X_DIRECTION)
                    ball.setxVelocity(Math.abs(ball.getxVelocity()));
                else if(getDirection(b) == Direction.Y_DIRECTION)
                    ball.setyVelocity(-Math.abs(ball.getyVelocity()));
                points += b.getPoints();
                toRemove.add(b);
            }
            else if(intersects(b) && getBallOrientation(b) == Orientation.TOP_LEFT){
                if(getDirection(b) == Direction.X_DIRECTION)
                    ball.setxVelocity(-Math.abs(ball.getxVelocity()));
                else if(getDirection(b) == Direction.Y_DIRECTION)
                    ball.setyVelocity(-Math.abs(ball.getyVelocity()));
                points += b.getPoints();
                toRemove.add(b);
            }
            else if(intersects(b) && getBallOrientation(b) == Orientation.BOTTOM_LEFT){
                if(getDirection(b) == Direction.X_DIRECTION)
                    ball.setxVelocity(-Math.abs(ball.getxVelocity()));
                else if(getDirection(b) == Direction.Y_DIRECTION)
                    ball.setyVelocity(Math.abs(ball.getyVelocity()));
                points += b.getPoints();
                toRemove.add(b);
            }
            else if(intersects(b) && getBallOrientation(b) == Orientation.BOTTOM_RIGHT){
                if(getDirection(b) == Direction.X_DIRECTION)
                    ball.setxVelocity(Math.abs(ball.getxVelocity()));
                else if(getDirection(b) == Direction.Y_DIRECTION)
                    ball.setyVelocity(Math.abs(ball.getyVelocity()));
                points += b.getPoints();
                toRemove.add(b);
            }

        }
        bricks.removeAll(toRemove);
        toRemove.clear();
    }

    // Used for functional decomposition
    private void doBallPaddleCollision(){

//        if(doInter(paddle) == Orientation.TOP){
//            ball.flipyVelocity();
//        }
//        else if(doInter(paddle) == Orientation.LEFT){
//            ball.flipxVelocity();
//        }

        if(intersects(paddle) && getBallOrientation(paddle) == Orientation.TOP){
            ball.setyVelocity(-Math.abs(ball.getyVelocity()));
        }
        else if(intersects(paddle) && getBallOrientation(paddle) == Orientation.BOTTOM){
            ball.setyVelocity(Math.abs(ball.getyVelocity()));
        }
        else if(intersects(paddle) && getBallOrientation(paddle) == Orientation.RIGHT){
            ball.setxVelocity(Math.abs(ball.getyVelocity()));
        }
        else if(intersects(paddle) && getBallOrientation(paddle) == Orientation.LEFT){
            ball.setxVelocity(-Math.abs(ball.getyVelocity()));
        }
        else if(intersects(paddle) && getBallOrientation(paddle) == Orientation.TOP_RIGHT){
            if(getDirection(paddle) == Direction.X_DIRECTION)
                ball.setxVelocity(-Math.abs(ball.getxVelocity()));
            else if(getDirection(paddle) == Direction.Y_DIRECTION)
                ball.setyVelocity(-Math.abs(ball.getyVelocity()));
        }
        else if(intersects(paddle) &&
                (getBallOrientation(paddle) == Orientation.BOTTOM_LEFT)){
            if(getDirection(paddle) == Direction.X_DIRECTION)
                ball.setxVelocity(-Math.abs(ball.getxVelocity()));
            else if(getDirection(paddle) == Direction.Y_DIRECTION)
                ball.setyVelocity(-Math.abs(ball.getyVelocity()));
        }
        else if(intersects(paddle) &&
                (getBallOrientation(paddle) == Orientation.BOTTOM_RIGHT)){
            if(getDirection(paddle) == Direction.X_DIRECTION)
                ball.setxVelocity(-Math.abs(ball.getxVelocity()));
            else if(getDirection(paddle) == Direction.Y_DIRECTION)
                ball.setyVelocity(-Math.abs(ball.getyVelocity()));
        }

    }

    private Orientation getBallOrientation(IPositionable rect){

        double bx = ball.getX() + ball.getRadius();
        double by = ball.getY() + ball.getRadius();

        boolean above = by < rect.getY();
        boolean below = by > rect.getMaxX();
        boolean rightOf = bx > rect.getMaxX();
        boolean leftOf = bx < rect.getX();

        if(above && rightOf)
            return Orientation.TOP_RIGHT;
        else if(above && leftOf)
            return Orientation.TOP_RIGHT;
        else if(below && rightOf)
            return Orientation.BOTTOM_RIGHT;
        else if(below && leftOf)
            return Orientation.BOTTOM_LEFT;

        else if(above)
            return Orientation.TOP;
        else if(below)
            return Orientation.BOTTOM;
        else if(rightOf)
            return Orientation.RIGHT;
        else if(leftOf)
            return Orientation.LEFT;

        return null;
    }

    private void repositionBall(IPositionable rect, Orientation orientation){
        if(orientation == Orientation.TOP_LEFT) {
            ball.setxPosition(rect.getX() - ball.getRadius());
            ball.setyPosition(rect.getX() - ball.getRadius());
        }
        if(orientation == Orientation.TOP_RIGHT){
            ball.setxPosition(rect.getX() + ball.getRadius());
            ball.setyPosition(rect.getX() - ball.getRadius());
        }
    }


    // if on corners
    private Direction getDirection(IPositionable rect){ // TODO return double 1 or -1 ?

        //double rx = nearestXOnRectangle(rect);
        //double ry = nearestYOnRectangle(rect);
        double bx = ball.getX();
        double by = ball.getY();
        double bxMax = ball.getMaxX();
        double byMax = ball.getMaxY();

        double rx = rect.getX();
        double ry = rect.getY();
        double rxMax = rect.getMaxX();
        double ryMax = rect.getMaxY();

        Orientation orientation = getBallOrientation(rect);

        if(orientation == Orientation.TOP_LEFT){
            return calculateDirection(rx, ry, bxMax, byMax);
        }
        else if(orientation == Orientation.TOP_RIGHT){
            return calculateDirection(rxMax, ry, bx, byMax);
        }
        else if(orientation == Orientation.BOTTOM_LEFT){
            return calculateDirection(rx, ryMax, bxMax, by);
        }
        else if(orientation == Orientation.BOTTOM_RIGHT){
            return calculateDirection(rxMax, ryMax, bx, by);
        }

        return Direction.NOTHING;
    }

    private Direction calculateDirection(double x1, double y1, double x2, double y2){
        if(Math.abs(x1 - x2) < Math.abs(y1 - y2))
            return Direction.X _DIRECTION;
        else
            return Direction.Y_DIRECTION;
    }


    /**
     *
     * @param rect
     * @return x-coordinate on the rectangle (of the center of the ball)
     */
    private double nearestXOnRectangle(IPositionable rect){

        double ballCenterX = ball.getX() + ball.getRadius();

        if(ballCenterX > rect.getMaxX())
            return rect.getMaxX();

        else if(ballCenterX < rect.getX())
            return rect.getX();

        else
            return ballCenterX;
    }

    /**
     *
     * @param rect
     * @return y-coordinate on the rectangle (of the center of the ball)
     */
    private double nearestYOnRectangle(IPositionable rect){

        double ballCenterY = ball.getY() + ball.getRadius();

        if(ballCenterY > rect.getMaxY())
            return rect.getMaxY();

        else if(ballCenterY < rect.getY())
            return rect.getY();

        else
            return ballCenterY;
    }


    public boolean intersects(IPositionable other) {

        boolean above = other.getMaxY() < ball.getY();
        boolean below = other.getY() > ball.getY() + ball.getHeight();
        boolean leftOf = other.getMaxX() < ball.getX();
        boolean rightOf = other.getX() > ball.getX() + ball.getWidth();

        return !(above || below || leftOf || rightOf);
    }

    // TODO FOR COLLISION: Edges
    //  -4 more bools for edges
    //  - separate x and y direction for sideways collision

//    public boolean intersects(Paddle paddle, Brick brick) {
//
//        IPositionable other;
//        if(paddle != null)
//            other = paddle;
//        else
//            other = brick;
//
//        // ball orientation
//        boolean above = ball.getMaxY() < other.getY();
//        boolean below = ball.getY() > other.getMaxX();
//        boolean rightOf = ball.getX() > other.getMaxX();
//        boolean leftOf = ball.getMaxX() < other.getX();
//
//        return !(above || below || leftOf || rightOf); // Ball is inside inside rectangle
//    }

    private double distance(double ballX, double ballY, double onRectX, double onRectY){
        double a = ballX - onRectX;
        double b = ballY - onRectY;
        return Math.sqrt(a*a + b*b);
    }

    private boolean distanceDiff(double ballPos, double rectPos){
        double distance = Math.abs(ballPos - rectPos); // Distance from ball position to to nearest point on rect

        if(distance - ball.getRadius() > 0)
            return false;
        else
            return true;
    }